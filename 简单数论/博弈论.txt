简单Nim游戏  

例题:https://www.acwing.com/problem/content/893/

给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个数字，其中第 i 个数字表示第 i 堆石子的数量。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n≤105,
1≤每堆石子数≤109
输入样例：
2
2 3
输出样例：
Yes

#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int n;

int main()
{
    cin >> n;
    int res = 0;
    while(n--)
    {
        int x;
        cin >> x;
        res ^= x;
    }
    if(res) cout << "Yes" << endl;
    else cout << "No" << endl;
    return 0;
}

算法核心:
定理 1 ：没有后继状态的状态是必败状态。

定理 2 ：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。

定理 3 ：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。

证明定理三   当所有堆的石子异或为0时先手必败 不为0时先手必胜
①假设所有异或起来结果是x x不等于0 x的最高位是1的位置是k
则必定有一堆石子数量二进制的第k位是1 假设这一堆石子是第p堆 则 p^x < p,
因为x二进制大于第k位的数字全都为0所以p^x可以将第k位变为0  此时p的高位全都不变 第k位变为0  则会变小
此时将p堆石子拿走p - x^p个石子 则第p堆石子还剩下x^p个石子 此时再去异或其他堆石子 因为p和其他堆石子异或得x
则x ^ x == 0所以当x不等于0时 必定存在一种情况拿走石子使得剩余石子异或为0 则先手必胜
②当所有堆石子异或为0 此时先手必败
用反证法 当所有堆石子异或为0时 先手必胜
则假设拿走的那堆变为了p'  因为先手必胜则 先手拿走了石子后异或结果为0
则将拿走和没拿之前的式子异或起来 没有拿的石堆保持不变  因为不变所以相同项异或为0
最后得  p' ^ p == 0 所以p' == p   又因为必须拿石头不能不拿 则假设错误 先手必败

集合Nim游戏

例题:https://www.acwing.com/problem/content/895/

给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 k，表示数字集合 S 中数字的个数。

第二行包含 k 个整数，其中第 i 个整数表示数字集合 S 中的第 i 个数 si。

第三行包含整数 n。

第四行包含 n 个整数，其中第 i 个整数表示第 i 堆石子的数量 hi。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n,k≤100,
1≤si,hi≤10000
输入样例：
2
2 5
3
2 4 7
输出样例：
Yes

#include <iostream>
#include <unordered_set>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 110,M = 10010;
int n,m;
int s[N],f[M];

int sg(int x)
{
    if(f[x] != -1) return f[x];
    
    unordered_set<int> us;
    
    for(int i = 0;i < n;i++)
    {
        int sum = s[i];
        if(x >= sum) us.insert(sg(x - sum));
    }
    
    for(int i = 0;;i++)
    {
        if(!us.count(i))
        {
            f[x] = i;
            break;
        }
    }
    return f[x];
}


int main()
{
    cin >> n;
    for(int i = 0;i < n;i++) cin >> s[i];
    cin >> m;
    int res = 0;
    memset(f,-1,sizeof f);
    for(int i = 0;i < m;i++)
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    
    if(res) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}

算法核心:
一堆石子状态的sg值代表的是该石子在该状态可以走到的下一个状态的所有sg值中不属于下一个状态的sg值中最小的自然数包括0
例如当该状态可以走到的下一个状态sg值集合是{1,3,5,4,0,6} 则当前状态的sg值为2
①单个游戏的情况(例如一个棋盘或者一堆石子)
若当前状态sg值为0则先手必败
若当前状态sg值非负则先手必胜 因为可以由当前状态转移到下一个sg值为0的状态
这里一定有一种情况可以转移到sg值为0的情况因为这是由sg的性质决定的 
若是下个状态无法变为sg为0 则当前的sg值一定为0 因为sg值就是由所有自然数中在所有下一个状态没有的值
②多个游戏组合Nim博弈模型
若所有当前状态的异或为0 则先手必败
若所有当前状态的异或非0 则先手必胜
跟第一种分析一样 当所有状态的异或非0时 一定有一种状态可以使得下一步异或非0 然后对方再移动的话就会变为非0
我方再移动就又会变为非0  一直往复最终一定是对方处于0状态 对方必败