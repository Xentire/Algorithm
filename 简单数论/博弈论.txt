简单Nim游戏  

例题:https://www.acwing.com/problem/content/893/

给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个数字，其中第 i 个数字表示第 i 堆石子的数量。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n≤105,
1≤每堆石子数≤109
输入样例：
2
2 3
输出样例：
Yes

#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int n;

int main()
{
    cin >> n;
    int res = 0;
    while(n--)
    {
        int x;
        cin >> x;
        res ^= x;
    }
    if(res) cout << "Yes" << endl;
    else cout << "No" << endl;
    return 0;
}

算法核心:
定理 1 ：没有后继状态的状态是必败状态。

定理 2 ：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。

定理 3 ：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。

证明定理三   当所有堆的石子异或为0时先手必败 不为0时先手必胜
①假设所有异或起来结果是x x不等于0 x的最高位是1的位置是k
则必定有一堆石子数量二进制的第k位是1 假设这一堆石子是第p堆 则 p^x < p,
因为x二进制大于第k位的数字全都为0所以p^x可以将第k位变为0  此时p的高位全都不变 第k位变为0  则会变小
此时将p堆石子拿走p - x^p个石子 则第p堆石子还剩下x^p个石子 此时再去异或其他堆石子 因为p和其他堆石子异或得x
则x ^ x == 0所以当x不等于0时 必定存在一种情况拿走石子使得剩余石子异或为0 则先手必胜
②当所有堆石子异或为0 此时先手必败
用反证法 当所有堆石子异或为0时 先手必胜
则假设拿走的那堆变为了p'  因为先手必胜则 先手拿走了石子后异或结果为0
则将拿走和没拿之前的式子异或起来 没有拿的石堆保持不变  因为不变所以相同项异或为0
最后得  p' ^ p == 0 所以p' == p   又因为必须拿石头不能不拿 则假设错误 先手必败