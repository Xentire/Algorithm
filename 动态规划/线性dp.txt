数字三角形

例题:https://www.acwing.com/problem/content/900/

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
输入格式
第一行包含整数 n，表示数字三角形的层数。

接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

输出格式
输出一个整数，表示最大的路径数字和。

数据范围
1≤n≤500,
−10000≤三角形中的整数≤10000
输入样例：
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例：
30

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 510;
int dp[N][N];
int n,arr[N][N];


int main()
{
    cin >> n;
    memset(dp,-0x3f,sizeof dp);
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= i;j++) 
        {
            cin >> arr[i][j];
            dp[i][j] = 0;
        }
    }
    dp[1][1] = arr[1][1];
    for(int i = 2;i <= n;i++)
    {
        for(int j = 1;j <= i;j++)
        {
            dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - 1]) + arr[i][j];
        }
    }
    int ans = -1e9; 
    for(int i = 1;i <= n;i++) ans = max(ans,dp[n][i]);
    
    cout << ans << endl;
    
    return 0;
}

算法核心:
处理边界问题 因为动态规划过程中会用到上一层的状态所以初始状态得处理好
因为数据范围是-10000 ~ +10000
所以不能将dp的边界值设置为0 因为0比负数大可能出现错误