滑雪

例题:https://www.acwing.com/problem/content/903/

给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

输入格式
第一行包含两个整数 R 和 C。

接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。

输出格式
输出一个整数，表示可完成的最长滑雪长度。

数据范围
1≤R,C≤300,
0≤矩阵中整数≤10000
输入样例：
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
输出样例：
25

#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 310;
int n,m;
int g[N][N];
int dp[N][N];
int dx[4] = {0,0,1,-1},dy[4] = {1,-1,0,0};

int dfs(int x,int y)
{
    int &v = dp[x][y];
    if(v != 0) return v;
    v = 1;
    for(int i = 0;i < 4;i++)
    {
        int nx = x + dx[i],ny = y + dy[i];
        if(nx <= n && ny <= m && nx >= 1 && ny >= 1 && g[nx][ny] < g[x][y])
        {
            v = max(v,dfs(nx,ny) + 1);
        }
    }
    
    return v;
}

int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++) cin >> g[i][j];
    }
    
    int ans = 0;
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            ans = max(ans,dfs(i,j));
        }
    }
   
    cout << ans << endl; 
    
    return 0;
}

算法核心:
dp[i][j]
状态集合:从i j节点出发 可以走过的所有路径的集合
状态属性:从i j节点出发 经过所有路径可以遍历到的节点个数的最大值
状态表示:
从i j 节点到
上下左右四个方向中可以走过的节点个数的最大值 加上当前节点即是 当前节点可以遍历到的节点个数的最大值
通过记忆化 存下所有遍历过的点可以避免重复遍历减少运算